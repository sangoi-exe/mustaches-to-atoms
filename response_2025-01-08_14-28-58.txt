Para corrigir os erros no seu código TypeScript, é necessário ajustar os tipos das funções e as estruturas de dados utilizadas. A maioria dos erros ocorre devido a incompatibilidades de tipo, principalmente porque algumas funções estão retornando `Babel.Statement` em vez de `Babel.Expression`, e porque você está tentando acessar propriedades (`fn`, `inverse`) que não existem no tipo `Babel.Expression`.

Segue uma explicação detalhada de como corrigir cada erro:

---

### **1. Propriedades `fn` e `inverse` não existem no tipo `Expression`**

**Erro em linhas 32, 35 e 37:**

```typescript
"Property 'fn' does not exist on type 'Expression'."
```

**Causas:**

- O parâmetro `options` está tipado como `Babel.Expression`, mas você está tentando acessar `options.fn` e `options.inverse`, propriedades que não existem nesse tipo.
  
**Solução:**

- Defina um tipo para `options` que inclua as propriedades `fn` e `inverse`.

**Passos:**

1. Crie uma interface para `options`:

```typescript
interface HelperOptions {
  fn: () => Babel.Expression;
  inverse?: () => Babel.Expression;
}
```

2. Ajuste as funções que utilizam `options` para usar o novo tipo:

```typescript
ifEqual: function (arg1, arg2, options: HelperOptions) {
  return Babel.conditionalExpression(
    Babel.binaryExpression("==", arg1, arg2),
    options.fn(),
    options.inverse ? options.inverse() : Babel.nullLiteral(),
  );
},
```

**Aplicação no código:**

```typescript
// Atualize o tipo HelperFunction para incluir o novo tipo options
type HelperFunction = (...args: (Babel.Expression | HelperOptions)[]) => Babel.Expression;

// Atualize as funções para usar HelperOptions
const assinaturaHelpers: AssinaturaHelpers = {
  ifEqual: function (arg1, arg2, options: HelperOptions) {
    return Babel.conditionalExpression(
      Babel.binaryExpression("==", arg1, arg2),
      options.fn(),
      options.inverse ? options.inverse() : Babel.nullLiteral(),
    );
  },
  // ... demais funções que utilizam options
};
```

---

### **2. Funções retornando `BlockStatement` em vez de `Expression`**

**Erros em linhas 93, 144, 275, 308, 381 e 399:**

```typescript
"Type '(params) => BlockStatement' is not assignable to type 'HelperFunction'."
```

**Causas:**

- As funções estão retornando `Babel.BlockStatement`, `Babel.IfStatement`, `Babel.SwitchStatement`, etc., que não são do tipo `Babel.Expression`. O `HelperFunction` espera que as funções retornem `Babel.Expression`.

**Solução:**

- Envolva o corpo da função em uma `Babel.ArrowFunctionExpression` e retorne a chamada dessa função, transformando o bloco de código em uma expressão.

**Passos:**

1. Modifique a função para retornar uma chamada de uma função anônima que contém o bloco de código.

2. Use `Babel.callExpression` em conjunto com `Babel.arrowFunctionExpression`.

**Exemplo aplicado à função `calculateCarouselMargin`:**

```typescript
calculateCarouselMargin: function (size: Babel.Expression) {
  const functionExpression = Babel.arrowFunctionExpression(
    [],
    Babel.blockStatement([condition1, condition2, defaultReturn])
  );
  return Babel.callExpression(functionExpression, []);
},
```

**Aplicação no código:**

- **Para `calculateCarouselMargin`:**

  ```typescript
  calculateCarouselMargin: function (size: Babel.Expression) {
    const condition1 = Babel.ifStatement(
      // ... seu código existente ...
    );

    // Envolva o bloco de código em uma função e retorne sua chamada
    const functionExpression = Babel.arrowFunctionExpression(
      [],
      Babel.blockStatement([condition1, condition2, defaultReturn])
    );
    return Babel.callExpression(functionExpression, []);
  },
  ```

- **Para `numberToPhone`:**

  ```typescript
  numberToPhone: function (valor: Babel.Expression) {
    const bodyStatements = [
      valorLimpo,
      matchCelularNovo,
      matchCelularAntigo,
      ifNovo
    ];

    const functionExpression = Babel.arrowFunctionExpression(
      [],
      Babel.blockStatement(bodyStatements)
    );
    return Babel.callExpression(functionExpression, []);
  },
  ```

- **Para as outras funções que retornam `IfStatement`, `SwitchStatement` ou `BlockStatement`, aplique a mesma técnica.**

---

### **3. Erro ao indexar um tipo com uma expressão do tipo 'string'**

**Erro em linha 87:**

```typescript
"Element implicitly has an 'any' type because expression of type 'string' can't be used to index type {...}"
```

**Causa:**

- Você está tentando acessar uma propriedade de um objeto usando uma string dinâmica, mas o TypeScript não reconhece que o índice está presente no tipo definido.

**Solução:**

- Assegure-se de que o índice está corretamente definido ou use o operador `in` para verificar se a propriedade existe antes de acessá-la.

**Passos:**

1. Verifique o objeto que está sendo indexado e confirme se ele possui uma assinatura de índice que permita o acesso com uma string.

2. Se necessário, defina uma assinatura de índice para o objeto.

**Aplicação no código:**

- Supondo que o objeto `operators` é um objeto literal com chaves conhecidas, mas você está tentando acessar com `operator.value`, que é uma `string`.

- Ajuste o tipo de `operators` para incluir uma assinatura de índice.

```typescript
const operators: { [key: string]: Babel.BinaryExpression["operator"] } = {
  "==": "==",
  "===": "===",
  // ... demais operadores
};
```

- Agora, ao acessar `operators[operator.value]`, o TypeScript reconhecerá que a chave pode ser uma string.

---

### **4. Corrigir o tipo dos parâmetros nas funções**

Algumas funções estão tipadas com parâmetros como `...params: Expression[]`, mas o TypeScript pode não estar reconhecendo corretamente quando você usa o operador rest (`...`).

**Solução:**

- Assegure-se de que os tipos dos parâmetros estão corretos e, se necessário, adicione anotações de tipo explícitas.

**Exemplo:**

```typescript
t: function (valor: Babel.Expression, ...params: Babel.Expression[]) {
  const options = params.pop() as Babel.Expression;

  // ... restante do código ...
},
```

---

### **Exemplo Complete do arquivo `assinaturaHelpers.ts` corrigido:**

```typescript
import * as Babel from "@babel/types";
import { AST as Glimmer } from "@glimmer/syntax";
import { resolveExpression } from "../converter/expressions.js";

type HelperFunction = (...args: (Babel.Expression | HelperOptions)[]) => Babel.Expression;

interface HelperOptions {
  fn: () => Babel.Expression;
  inverse?: () => Babel.Expression;
}

interface AssinaturaHelpers {
  [key: string]: HelperFunction;
}

const assinaturaHelpers: AssinaturaHelpers = {
  ifEqual: function (arg1, arg2, options: HelperOptions) {
    return Babel.conditionalExpression(
      Babel.binaryExpression("==", arg1, arg2),
      options.fn(),
      options.inverse ? options.inverse() : Babel.nullLiteral(),
    );
  },

  ifNEqual: function (arg1, arg2, options: HelperOptions) {
    return Babel.conditionalExpression(
      Babel.binaryExpression("!=", arg1, arg2),
      options.fn(),
      Babel.nullLiteral(),
    );
  },

  // Ajuste na função switch
  switch: function (value, options: HelperOptions) {
    if (!options || !options.fn) {
      return Babel.nullLiteral();
    }
    // Exemplo simplificado, ajuste conforme sua necessidade
    return options.fn();
  },

  // Ajuste na função case
  case: function (value, options: HelperOptions) {
    return options.fn();
  },

  default: function (options: HelperOptions) {
    return options.fn();
  },

  // ... demais helpers ...

  calculateCarouselMargin: function (size: Babel.Expression) {
    const condition1 = Babel.ifStatement(
      // ... seu código existente ...
    );

    const functionExpression = Babel.arrowFunctionExpression(
      [],
      Babel.blockStatement([condition1, condition2, defaultReturn])
    );
    return Babel.callExpression(functionExpression, []);
  },

  numberToPhone: function (valor: Babel.Expression) {
    // ... seu código existente ...

    const bodyStatements = [
      valorLimpo,
      matchCelularNovo,
      matchCelularAntigo,
      ifNovo
    ];

    const functionExpression = Babel.arrowFunctionExpression(
      [],
      Babel.blockStatement(bodyStatements)
    );
    return Babel.callExpression(functionExpression, []);
  },

  // ... demais funções ajustadas ...

};

export const getAssinaturaHelper = (
  helperName: string,
  blockStatement: Glimmer.BlockStatement,
): Babel.Expression | null => {
  const helper = assinaturaHelpers[helperName];
  if (helper) {
    const params = blockStatement.params.map((p) => resolveExpression(p));
    let options: HelperOptions;

    if (blockStatement.program) {
      options = {
        fn: () => createRootChildren(blockStatement.program.body),
      };
    }

    if (blockStatement.inverse) {
      options = {
        fn: () => createRootChildren(blockStatement.program.body),
        inverse: () => createRootChildren(blockStatement.inverse.body),
      };
    }

    return helper(...params, options);
  }
  return null;
};

// Função auxiliar para criar os filhos da raiz
function createRootChildren(body: Glimmer.Statement[]): Babel.Expression {
  // ... seu código existente ...
}
```

---

### **5. Corrija outros erros pontuais**

**Erros nas linhas 490 e 494:**

```typescript
"Argument of type 'Expression[]' is not assignable to parameter of type 'Expression'."
```

**Causa:**

- Você está passando um array de `Expression[]` onde uma única `Expression` é esperada.

**Solução:**

- Ajuste o código para passar uma única expressão ou modifique a função para aceitar um array de expressões, se for apropriado.

---

**Resumo:**

- **Defina tipos adequados para os parâmetros e retornos das funções.**
- **Envolva blocos de código em funções imediatamente invocadas (IIFE) para transformá-los em expressões.**
- **Ajuste acessos a propriedades em objetos para corresponder aos tipos definidos.**
- **Garanta que as funções retornam tipos compatíveis com o que é esperado pelo TypeScript.**

Implementando essas correções, seu código deve compilar sem os erros apontados.